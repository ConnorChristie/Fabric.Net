// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: orderer/kafka.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Orderer {

  /// <summary>Holder for reflection information generated from orderer/kafka.proto</summary>
  public static partial class KafkaReflection {

    #region Descriptor
    /// <summary>File descriptor for orderer/kafka.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static KafkaReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChNvcmRlcmVyL2thZmthLnByb3RvEgdvcmRlcmVyIq8BCgxLYWZrYU1lc3Nh",
            "Z2USLwoHcmVndWxhchgBIAEoCzIcLm9yZGVyZXIuS2Fma2FNZXNzYWdlUmVn",
            "dWxhckgAEjUKC3RpbWVfdG9fY3V0GAIgASgLMh4ub3JkZXJlci5LYWZrYU1l",
            "c3NhZ2VUaW1lVG9DdXRIABIvCgdjb25uZWN0GAMgASgLMhwub3JkZXJlci5L",
            "YWZrYU1lc3NhZ2VDb25uZWN0SABCBgoEVHlwZSK0AQoTS2Fma2FNZXNzYWdl",
            "UmVndWxhchIPCgdwYXlsb2FkGAEgASgMEhIKCmNvbmZpZ19zZXEYAiABKAQS",
            "MQoFY2xhc3MYAyABKA4yIi5vcmRlcmVyLkthZmthTWVzc2FnZVJlZ3VsYXIu",
            "Q2xhc3MSFwoPb3JpZ2luYWxfb2Zmc2V0GAQgASgDIiwKBUNsYXNzEgsKB1VO",
            "S05PV04QABIKCgZOT1JNQUwQARIKCgZDT05GSUcQAiItChVLYWZrYU1lc3Nh",
            "Z2VUaW1lVG9DdXQSFAoMYmxvY2tfbnVtYmVyGAEgASgEIiYKE0thZmthTWVz",
            "c2FnZUNvbm5lY3QSDwoHcGF5bG9hZBgBIAEoDCJ+Cg1LYWZrYU1ldGFkYXRh",
            "Eh0KFWxhc3Rfb2Zmc2V0X3BlcnNpc3RlZBgBIAEoAxImCh5sYXN0X29yaWdp",
            "bmFsX29mZnNldF9wcm9jZXNzZWQYAiABKAMSJgoebGFzdF9yZXN1Ym1pdHRl",
            "ZF9jb25maWdfb2Zmc2V0GAMgASgDQlUKJW9yZy5oeXBlcmxlZGdlci5mYWJy",
            "aWMucHJvdG9zLm9yZGVyZXJaLGdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFi",
            "cmljL3Byb3Rvcy9vcmRlcmVyYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Orderer.KafkaMessage), global::Orderer.KafkaMessage.Parser, new[]{ "Regular", "TimeToCut", "Connect" }, new[]{ "Type" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Orderer.KafkaMessageRegular), global::Orderer.KafkaMessageRegular.Parser, new[]{ "Payload", "ConfigSeq", "Class", "OriginalOffset" }, null, new[]{ typeof(global::Orderer.KafkaMessageRegular.Types.Class) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Orderer.KafkaMessageTimeToCut), global::Orderer.KafkaMessageTimeToCut.Parser, new[]{ "BlockNumber" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Orderer.KafkaMessageConnect), global::Orderer.KafkaMessageConnect.Parser, new[]{ "Payload" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Orderer.KafkaMetadata), global::Orderer.KafkaMetadata.Parser, new[]{ "LastOffsetPersisted", "LastOriginalOffsetProcessed", "LastResubmittedConfigOffset" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// KafkaMessage is a wrapper type for the messages
  /// that the Kafka-based orderer deals with.
  /// </summary>
  public sealed partial class KafkaMessage : pb::IMessage<KafkaMessage> {
    private static readonly pb::MessageParser<KafkaMessage> _parser = new pb::MessageParser<KafkaMessage>(() => new KafkaMessage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KafkaMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Orderer.KafkaReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessage(KafkaMessage other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.Regular:
          Regular = other.Regular.Clone();
          break;
        case TypeOneofCase.TimeToCut:
          TimeToCut = other.TimeToCut.Clone();
          break;
        case TypeOneofCase.Connect:
          Connect = other.Connect.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessage Clone() {
      return new KafkaMessage(this);
    }

    /// <summary>Field number for the "regular" field.</summary>
    public const int RegularFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Orderer.KafkaMessageRegular Regular {
      get { return typeCase_ == TypeOneofCase.Regular ? (global::Orderer.KafkaMessageRegular) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Regular;
      }
    }

    /// <summary>Field number for the "time_to_cut" field.</summary>
    public const int TimeToCutFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Orderer.KafkaMessageTimeToCut TimeToCut {
      get { return typeCase_ == TypeOneofCase.TimeToCut ? (global::Orderer.KafkaMessageTimeToCut) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.TimeToCut;
      }
    }

    /// <summary>Field number for the "connect" field.</summary>
    public const int ConnectFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Orderer.KafkaMessageConnect Connect {
      get { return typeCase_ == TypeOneofCase.Connect ? (global::Orderer.KafkaMessageConnect) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Connect;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "Type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Regular = 1,
      TimeToCut = 2,
      Connect = 3,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KafkaMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KafkaMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Regular, other.Regular)) return false;
      if (!object.Equals(TimeToCut, other.TimeToCut)) return false;
      if (!object.Equals(Connect, other.Connect)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.Regular) hash ^= Regular.GetHashCode();
      if (typeCase_ == TypeOneofCase.TimeToCut) hash ^= TimeToCut.GetHashCode();
      if (typeCase_ == TypeOneofCase.Connect) hash ^= Connect.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (typeCase_ == TypeOneofCase.Regular) {
        output.WriteRawTag(10);
        output.WriteMessage(Regular);
      }
      if (typeCase_ == TypeOneofCase.TimeToCut) {
        output.WriteRawTag(18);
        output.WriteMessage(TimeToCut);
      }
      if (typeCase_ == TypeOneofCase.Connect) {
        output.WriteRawTag(26);
        output.WriteMessage(Connect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.Regular) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Regular);
      }
      if (typeCase_ == TypeOneofCase.TimeToCut) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeToCut);
      }
      if (typeCase_ == TypeOneofCase.Connect) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Connect);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KafkaMessage other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Regular:
          if (Regular == null) {
            Regular = new global::Orderer.KafkaMessageRegular();
          }
          Regular.MergeFrom(other.Regular);
          break;
        case TypeOneofCase.TimeToCut:
          if (TimeToCut == null) {
            TimeToCut = new global::Orderer.KafkaMessageTimeToCut();
          }
          TimeToCut.MergeFrom(other.TimeToCut);
          break;
        case TypeOneofCase.Connect:
          if (Connect == null) {
            Connect = new global::Orderer.KafkaMessageConnect();
          }
          Connect.MergeFrom(other.Connect);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Orderer.KafkaMessageRegular subBuilder = new global::Orderer.KafkaMessageRegular();
            if (typeCase_ == TypeOneofCase.Regular) {
              subBuilder.MergeFrom(Regular);
            }
            input.ReadMessage(subBuilder);
            Regular = subBuilder;
            break;
          }
          case 18: {
            global::Orderer.KafkaMessageTimeToCut subBuilder = new global::Orderer.KafkaMessageTimeToCut();
            if (typeCase_ == TypeOneofCase.TimeToCut) {
              subBuilder.MergeFrom(TimeToCut);
            }
            input.ReadMessage(subBuilder);
            TimeToCut = subBuilder;
            break;
          }
          case 26: {
            global::Orderer.KafkaMessageConnect subBuilder = new global::Orderer.KafkaMessageConnect();
            if (typeCase_ == TypeOneofCase.Connect) {
              subBuilder.MergeFrom(Connect);
            }
            input.ReadMessage(subBuilder);
            Connect = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// KafkaMessageRegular wraps a marshalled envelope.
  /// </summary>
  public sealed partial class KafkaMessageRegular : pb::IMessage<KafkaMessageRegular> {
    private static readonly pb::MessageParser<KafkaMessageRegular> _parser = new pb::MessageParser<KafkaMessageRegular>(() => new KafkaMessageRegular());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KafkaMessageRegular> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Orderer.KafkaReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageRegular() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageRegular(KafkaMessageRegular other) : this() {
      payload_ = other.payload_;
      configSeq_ = other.configSeq_;
      class_ = other.class_;
      originalOffset_ = other.originalOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageRegular Clone() {
      return new KafkaMessageRegular(this);
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 1;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config_seq" field.</summary>
    public const int ConfigSeqFieldNumber = 2;
    private ulong configSeq_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ConfigSeq {
      get { return configSeq_; }
      set {
        configSeq_ = value;
      }
    }

    /// <summary>Field number for the "class" field.</summary>
    public const int ClassFieldNumber = 3;
    private global::Orderer.KafkaMessageRegular.Types.Class class_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Orderer.KafkaMessageRegular.Types.Class Class {
      get { return class_; }
      set {
        class_ = value;
      }
    }

    /// <summary>Field number for the "original_offset" field.</summary>
    public const int OriginalOffsetFieldNumber = 4;
    private long originalOffset_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long OriginalOffset {
      get { return originalOffset_; }
      set {
        originalOffset_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KafkaMessageRegular);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KafkaMessageRegular other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Payload != other.Payload) return false;
      if (ConfigSeq != other.ConfigSeq) return false;
      if (Class != other.Class) return false;
      if (OriginalOffset != other.OriginalOffset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (ConfigSeq != 0UL) hash ^= ConfigSeq.GetHashCode();
      if (Class != 0) hash ^= Class.GetHashCode();
      if (OriginalOffset != 0L) hash ^= OriginalOffset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Payload.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Payload);
      }
      if (ConfigSeq != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(ConfigSeq);
      }
      if (Class != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Class);
      }
      if (OriginalOffset != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(OriginalOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (ConfigSeq != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ConfigSeq);
      }
      if (Class != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Class);
      }
      if (OriginalOffset != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(OriginalOffset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KafkaMessageRegular other) {
      if (other == null) {
        return;
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      if (other.ConfigSeq != 0UL) {
        ConfigSeq = other.ConfigSeq;
      }
      if (other.Class != 0) {
        Class = other.Class;
      }
      if (other.OriginalOffset != 0L) {
        OriginalOffset = other.OriginalOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Payload = input.ReadBytes();
            break;
          }
          case 16: {
            ConfigSeq = input.ReadUInt64();
            break;
          }
          case 24: {
            class_ = (global::Orderer.KafkaMessageRegular.Types.Class) input.ReadEnum();
            break;
          }
          case 32: {
            OriginalOffset = input.ReadInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the KafkaMessageRegular message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Class {
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        [pbr::OriginalName("NORMAL")] Normal = 1,
        [pbr::OriginalName("CONFIG")] Config = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// KafkaMessageTimeToCut is used to signal to the orderers
  /// that it is time to cut block &lt;block_number>.
  /// </summary>
  public sealed partial class KafkaMessageTimeToCut : pb::IMessage<KafkaMessageTimeToCut> {
    private static readonly pb::MessageParser<KafkaMessageTimeToCut> _parser = new pb::MessageParser<KafkaMessageTimeToCut>(() => new KafkaMessageTimeToCut());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KafkaMessageTimeToCut> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Orderer.KafkaReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageTimeToCut() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageTimeToCut(KafkaMessageTimeToCut other) : this() {
      blockNumber_ = other.blockNumber_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageTimeToCut Clone() {
      return new KafkaMessageTimeToCut(this);
    }

    /// <summary>Field number for the "block_number" field.</summary>
    public const int BlockNumberFieldNumber = 1;
    private ulong blockNumber_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong BlockNumber {
      get { return blockNumber_; }
      set {
        blockNumber_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KafkaMessageTimeToCut);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KafkaMessageTimeToCut other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BlockNumber != other.BlockNumber) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BlockNumber != 0UL) hash ^= BlockNumber.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BlockNumber != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(BlockNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BlockNumber != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BlockNumber);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KafkaMessageTimeToCut other) {
      if (other == null) {
        return;
      }
      if (other.BlockNumber != 0UL) {
        BlockNumber = other.BlockNumber;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            BlockNumber = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// KafkaMessageConnect is posted by an orderer upon booting up.
  /// It is used to prevent the panic that would be caused if we
  /// were to consume an empty partition. It is ignored by all
  /// orderers when processing the partition.
  /// </summary>
  public sealed partial class KafkaMessageConnect : pb::IMessage<KafkaMessageConnect> {
    private static readonly pb::MessageParser<KafkaMessageConnect> _parser = new pb::MessageParser<KafkaMessageConnect>(() => new KafkaMessageConnect());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KafkaMessageConnect> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Orderer.KafkaReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageConnect() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageConnect(KafkaMessageConnect other) : this() {
      payload_ = other.payload_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMessageConnect Clone() {
      return new KafkaMessageConnect(this);
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 1;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KafkaMessageConnect);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KafkaMessageConnect other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Payload != other.Payload) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Payload.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Payload);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KafkaMessageConnect other) {
      if (other == null) {
        return;
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Payload = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// KafkaMetadata is encoded into the ORDERER block to keep track of
  /// Kafka-related metadata associated with this block.
  /// </summary>
  public sealed partial class KafkaMetadata : pb::IMessage<KafkaMetadata> {
    private static readonly pb::MessageParser<KafkaMetadata> _parser = new pb::MessageParser<KafkaMetadata>(() => new KafkaMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KafkaMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Orderer.KafkaReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMetadata(KafkaMetadata other) : this() {
      lastOffsetPersisted_ = other.lastOffsetPersisted_;
      lastOriginalOffsetProcessed_ = other.lastOriginalOffsetProcessed_;
      lastResubmittedConfigOffset_ = other.lastResubmittedConfigOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KafkaMetadata Clone() {
      return new KafkaMetadata(this);
    }

    /// <summary>Field number for the "last_offset_persisted" field.</summary>
    public const int LastOffsetPersistedFieldNumber = 1;
    private long lastOffsetPersisted_;
    /// <summary>
    /// LastOffsetPersisted is the encoded value for the Metadata message
    /// which is encoded in the ORDERER block metadata index for the case
    /// of the Kafka-based orderer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastOffsetPersisted {
      get { return lastOffsetPersisted_; }
      set {
        lastOffsetPersisted_ = value;
      }
    }

    /// <summary>Field number for the "last_original_offset_processed" field.</summary>
    public const int LastOriginalOffsetProcessedFieldNumber = 2;
    private long lastOriginalOffsetProcessed_;
    /// <summary>
    /// LastOriginalOffsetProcessed is used to keep track of the newest
    /// offset processed if a message is re-validated and re-ordered.
    /// This value is used to deduplicate re-submitted messages from
    /// multiple orderer so that we don't bother re-processing it again.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastOriginalOffsetProcessed {
      get { return lastOriginalOffsetProcessed_; }
      set {
        lastOriginalOffsetProcessed_ = value;
      }
    }

    /// <summary>Field number for the "last_resubmitted_config_offset" field.</summary>
    public const int LastResubmittedConfigOffsetFieldNumber = 3;
    private long lastResubmittedConfigOffset_;
    /// <summary>
    /// LastResubmittedConfigOffset is used to capture the newest offset of
    /// CONFIG kafka message, which is revalidated and resubmitted. By comparing
    /// this with LastOriginalOffsetProcessed, we could detemine whether there
    /// are still CONFIG messages that have been resubmitted but NOT processed
    /// yet. It's used as condition to block ingress messages, so we could reduce
    /// the overhead of repeatedly resubmitting messages as config seq keeps
    /// advancing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastResubmittedConfigOffset {
      get { return lastResubmittedConfigOffset_; }
      set {
        lastResubmittedConfigOffset_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KafkaMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KafkaMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LastOffsetPersisted != other.LastOffsetPersisted) return false;
      if (LastOriginalOffsetProcessed != other.LastOriginalOffsetProcessed) return false;
      if (LastResubmittedConfigOffset != other.LastResubmittedConfigOffset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LastOffsetPersisted != 0L) hash ^= LastOffsetPersisted.GetHashCode();
      if (LastOriginalOffsetProcessed != 0L) hash ^= LastOriginalOffsetProcessed.GetHashCode();
      if (LastResubmittedConfigOffset != 0L) hash ^= LastResubmittedConfigOffset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LastOffsetPersisted != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(LastOffsetPersisted);
      }
      if (LastOriginalOffsetProcessed != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(LastOriginalOffsetProcessed);
      }
      if (LastResubmittedConfigOffset != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(LastResubmittedConfigOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LastOffsetPersisted != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LastOffsetPersisted);
      }
      if (LastOriginalOffsetProcessed != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LastOriginalOffsetProcessed);
      }
      if (LastResubmittedConfigOffset != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LastResubmittedConfigOffset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KafkaMetadata other) {
      if (other == null) {
        return;
      }
      if (other.LastOffsetPersisted != 0L) {
        LastOffsetPersisted = other.LastOffsetPersisted;
      }
      if (other.LastOriginalOffsetProcessed != 0L) {
        LastOriginalOffsetProcessed = other.LastOriginalOffsetProcessed;
      }
      if (other.LastResubmittedConfigOffset != 0L) {
        LastResubmittedConfigOffset = other.LastResubmittedConfigOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LastOffsetPersisted = input.ReadInt64();
            break;
          }
          case 16: {
            LastOriginalOffsetProcessed = input.ReadInt64();
            break;
          }
          case 24: {
            LastResubmittedConfigOffset = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
