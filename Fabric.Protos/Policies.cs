// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: common/policies.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Common {

  /// <summary>Holder for reflection information generated from common/policies.proto</summary>
  public static partial class PoliciesReflection {

    #region Descriptor
    /// <summary>File descriptor for common/policies.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PoliciesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVjb21tb24vcG9saWNpZXMucHJvdG8SBmNvbW1vbhoXbXNwL21zcF9wcmlu",
            "Y2lwYWwucHJvdG8iawoGUG9saWN5EgwKBHR5cGUYASABKAUSDQoFdmFsdWUY",
            "AiABKAwiRAoKUG9saWN5VHlwZRILCgdVTktOT1dOEAASDQoJU0lHTkFUVVJF",
            "EAESBwoDTVNQEAISEQoNSU1QTElDSVRfTUVUQRADInsKF1NpZ25hdHVyZVBv",
            "bGljeUVudmVsb3BlEg8KB3ZlcnNpb24YASABKAUSJQoEcnVsZRgCIAEoCzIX",
            "LmNvbW1vbi5TaWduYXR1cmVQb2xpY3kSKAoKaWRlbnRpdGllcxgDIAMoCzIU",
            "LmNvbW1vbi5NU1BQcmluY2lwYWwinwEKD1NpZ25hdHVyZVBvbGljeRITCglz",
            "aWduZWRfYnkYASABKAVIABIyCghuX291dF9vZhgCIAEoCzIeLmNvbW1vbi5T",
            "aWduYXR1cmVQb2xpY3kuTk91dE9mSAAaOwoGTk91dE9mEgkKAW4YASABKAUS",
            "JgoFcnVsZXMYAiADKAsyFy5jb21tb24uU2lnbmF0dXJlUG9saWN5QgYKBFR5",
            "cGUifwoSSW1wbGljaXRNZXRhUG9saWN5EhIKCnN1Yl9wb2xpY3kYASABKAkS",
            "LQoEcnVsZRgCIAEoDjIfLmNvbW1vbi5JbXBsaWNpdE1ldGFQb2xpY3kuUnVs",
            "ZSImCgRSdWxlEgcKA0FOWRAAEgcKA0FMTBABEgwKCE1BSk9SSVRZEAJCUwok",
            "b3JnLmh5cGVybGVkZ2VyLmZhYnJpYy5wcm90b3MuY29tbW9uWitnaXRodWIu",
            "Y29tL2h5cGVybGVkZ2VyL2ZhYnJpYy9wcm90b3MvY29tbW9uYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Common.MspPrincipalReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Common.Policy), global::Common.Policy.Parser, new[]{ "Type", "Value" }, null, new[]{ typeof(global::Common.Policy.Types.PolicyType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Common.SignaturePolicyEnvelope), global::Common.SignaturePolicyEnvelope.Parser, new[]{ "Version", "Rule", "Identities" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Common.SignaturePolicy), global::Common.SignaturePolicy.Parser, new[]{ "SignedBy", "NOutOf" }, new[]{ "Type" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Common.SignaturePolicy.Types.NOutOf), global::Common.SignaturePolicy.Types.NOutOf.Parser, new[]{ "N", "Rules" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Common.ImplicitMetaPolicy), global::Common.ImplicitMetaPolicy.Parser, new[]{ "SubPolicy", "Rule" }, null, new[]{ typeof(global::Common.ImplicitMetaPolicy.Types.Rule) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
  /// multiple policy engines, this is typed as a oneof for now
  /// </summary>
  public sealed partial class Policy : pb::IMessage<Policy> {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Common.PoliciesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy(Policy other) : this() {
      type_ = other.type_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private int type_;
    /// <summary>
    /// For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private pb::ByteString value_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Type);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Type);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = input.ReadInt32();
            break;
          }
          case 18: {
            Value = input.ReadBytes();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Policy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum PolicyType {
        /// <summary>
        /// Reserved to check for proper initialization
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        [pbr::OriginalName("SIGNATURE")] Signature = 1,
        [pbr::OriginalName("MSP")] Msp = 2,
        [pbr::OriginalName("IMPLICIT_META")] ImplicitMeta = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
  /// </summary>
  public sealed partial class SignaturePolicyEnvelope : pb::IMessage<SignaturePolicyEnvelope> {
    private static readonly pb::MessageParser<SignaturePolicyEnvelope> _parser = new pb::MessageParser<SignaturePolicyEnvelope>(() => new SignaturePolicyEnvelope());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignaturePolicyEnvelope> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Common.PoliciesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicyEnvelope() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicyEnvelope(SignaturePolicyEnvelope other) : this() {
      version_ = other.version_;
      rule_ = other.rule_ != null ? other.rule_.Clone() : null;
      identities_ = other.identities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicyEnvelope Clone() {
      return new SignaturePolicyEnvelope(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private int version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "rule" field.</summary>
    public const int RuleFieldNumber = 2;
    private global::Common.SignaturePolicy rule_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Common.SignaturePolicy Rule {
      get { return rule_; }
      set {
        rule_ = value;
      }
    }

    /// <summary>Field number for the "identities" field.</summary>
    public const int IdentitiesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Common.MSPPrincipal> _repeated_identities_codec
        = pb::FieldCodec.ForMessage(26, global::Common.MSPPrincipal.Parser);
    private readonly pbc::RepeatedField<global::Common.MSPPrincipal> identities_ = new pbc::RepeatedField<global::Common.MSPPrincipal>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Common.MSPPrincipal> Identities {
      get { return identities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignaturePolicyEnvelope);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignaturePolicyEnvelope other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (!object.Equals(Rule, other.Rule)) return false;
      if(!identities_.Equals(other.identities_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version != 0) hash ^= Version.GetHashCode();
      if (rule_ != null) hash ^= Rule.GetHashCode();
      hash ^= identities_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Version);
      }
      if (rule_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Rule);
      }
      identities_.WriteTo(output, _repeated_identities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      if (rule_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rule);
      }
      size += identities_.CalculateSize(_repeated_identities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignaturePolicyEnvelope other) {
      if (other == null) {
        return;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
      if (other.rule_ != null) {
        if (rule_ == null) {
          rule_ = new global::Common.SignaturePolicy();
        }
        Rule.MergeFrom(other.Rule);
      }
      identities_.Add(other.identities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = input.ReadInt32();
            break;
          }
          case 18: {
            if (rule_ == null) {
              rule_ = new global::Common.SignaturePolicy();
            }
            input.ReadMessage(rule_);
            break;
          }
          case 26: {
            identities_.AddEntriesFrom(input, _repeated_identities_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
  /// policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
  /// to express AND as well as OR, as well as of course N out of the following M policies
  /// SignedBy implies that the signature is from a valid certificate which is signed by the trusted
  /// authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
  /// and will be the CA for more traditional certificates
  /// </summary>
  public sealed partial class SignaturePolicy : pb::IMessage<SignaturePolicy> {
    private static readonly pb::MessageParser<SignaturePolicy> _parser = new pb::MessageParser<SignaturePolicy>(() => new SignaturePolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignaturePolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Common.PoliciesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicy(SignaturePolicy other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.SignedBy:
          SignedBy = other.SignedBy;
          break;
        case TypeOneofCase.NOutOf:
          NOutOf = other.NOutOf.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignaturePolicy Clone() {
      return new SignaturePolicy(this);
    }

    /// <summary>Field number for the "signed_by" field.</summary>
    public const int SignedByFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SignedBy {
      get { return typeCase_ == TypeOneofCase.SignedBy ? (int) type_ : 0; }
      set {
        type_ = value;
        typeCase_ = TypeOneofCase.SignedBy;
      }
    }

    /// <summary>Field number for the "n_out_of" field.</summary>
    public const int NOutOfFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Common.SignaturePolicy.Types.NOutOf NOutOf {
      get { return typeCase_ == TypeOneofCase.NOutOf ? (global::Common.SignaturePolicy.Types.NOutOf) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.NOutOf;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "Type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      SignedBy = 1,
      NOutOf = 2,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignaturePolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignaturePolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SignedBy != other.SignedBy) return false;
      if (!object.Equals(NOutOf, other.NOutOf)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.SignedBy) hash ^= SignedBy.GetHashCode();
      if (typeCase_ == TypeOneofCase.NOutOf) hash ^= NOutOf.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (typeCase_ == TypeOneofCase.SignedBy) {
        output.WriteRawTag(8);
        output.WriteInt32(SignedBy);
      }
      if (typeCase_ == TypeOneofCase.NOutOf) {
        output.WriteRawTag(18);
        output.WriteMessage(NOutOf);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.SignedBy) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SignedBy);
      }
      if (typeCase_ == TypeOneofCase.NOutOf) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NOutOf);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignaturePolicy other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.SignedBy:
          SignedBy = other.SignedBy;
          break;
        case TypeOneofCase.NOutOf:
          if (NOutOf == null) {
            NOutOf = new global::Common.SignaturePolicy.Types.NOutOf();
          }
          NOutOf.MergeFrom(other.NOutOf);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SignedBy = input.ReadInt32();
            break;
          }
          case 18: {
            global::Common.SignaturePolicy.Types.NOutOf subBuilder = new global::Common.SignaturePolicy.Types.NOutOf();
            if (typeCase_ == TypeOneofCase.NOutOf) {
              subBuilder.MergeFrom(NOutOf);
            }
            input.ReadMessage(subBuilder);
            NOutOf = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SignaturePolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class NOutOf : pb::IMessage<NOutOf> {
        private static readonly pb::MessageParser<NOutOf> _parser = new pb::MessageParser<NOutOf>(() => new NOutOf());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NOutOf> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Common.SignaturePolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NOutOf() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NOutOf(NOutOf other) : this() {
          n_ = other.n_;
          rules_ = other.rules_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NOutOf Clone() {
          return new NOutOf(this);
        }

        /// <summary>Field number for the "n" field.</summary>
        public const int NFieldNumber = 1;
        private int n_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int N {
          get { return n_; }
          set {
            n_ = value;
          }
        }

        /// <summary>Field number for the "rules" field.</summary>
        public const int RulesFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Common.SignaturePolicy> _repeated_rules_codec
            = pb::FieldCodec.ForMessage(18, global::Common.SignaturePolicy.Parser);
        private readonly pbc::RepeatedField<global::Common.SignaturePolicy> rules_ = new pbc::RepeatedField<global::Common.SignaturePolicy>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Common.SignaturePolicy> Rules {
          get { return rules_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NOutOf);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NOutOf other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (N != other.N) return false;
          if(!rules_.Equals(other.rules_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (N != 0) hash ^= N.GetHashCode();
          hash ^= rules_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (N != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(N);
          }
          rules_.WriteTo(output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (N != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(N);
          }
          size += rules_.CalculateSize(_repeated_rules_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NOutOf other) {
          if (other == null) {
            return;
          }
          if (other.N != 0) {
            N = other.N;
          }
          rules_.Add(other.rules_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                N = input.ReadInt32();
                break;
              }
              case 18: {
                rules_.AddEntriesFrom(input, _repeated_rules_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
  /// It is implicit because the rule is generate implicitly based on the number of sub policies
  /// It is meta because it depends only on the result of other policies
  /// When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
  /// of name sub_policy, evaluates the collection and applies the rule.
  /// For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
  /// each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
  /// 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
  /// </summary>
  public sealed partial class ImplicitMetaPolicy : pb::IMessage<ImplicitMetaPolicy> {
    private static readonly pb::MessageParser<ImplicitMetaPolicy> _parser = new pb::MessageParser<ImplicitMetaPolicy>(() => new ImplicitMetaPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImplicitMetaPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Common.PoliciesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImplicitMetaPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImplicitMetaPolicy(ImplicitMetaPolicy other) : this() {
      subPolicy_ = other.subPolicy_;
      rule_ = other.rule_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImplicitMetaPolicy Clone() {
      return new ImplicitMetaPolicy(this);
    }

    /// <summary>Field number for the "sub_policy" field.</summary>
    public const int SubPolicyFieldNumber = 1;
    private string subPolicy_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SubPolicy {
      get { return subPolicy_; }
      set {
        subPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rule" field.</summary>
    public const int RuleFieldNumber = 2;
    private global::Common.ImplicitMetaPolicy.Types.Rule rule_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Common.ImplicitMetaPolicy.Types.Rule Rule {
      get { return rule_; }
      set {
        rule_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImplicitMetaPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImplicitMetaPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SubPolicy != other.SubPolicy) return false;
      if (Rule != other.Rule) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SubPolicy.Length != 0) hash ^= SubPolicy.GetHashCode();
      if (Rule != 0) hash ^= Rule.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SubPolicy.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SubPolicy);
      }
      if (Rule != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Rule);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SubPolicy.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SubPolicy);
      }
      if (Rule != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Rule);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImplicitMetaPolicy other) {
      if (other == null) {
        return;
      }
      if (other.SubPolicy.Length != 0) {
        SubPolicy = other.SubPolicy;
      }
      if (other.Rule != 0) {
        Rule = other.Rule;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SubPolicy = input.ReadString();
            break;
          }
          case 16: {
            rule_ = (global::Common.ImplicitMetaPolicy.Types.Rule) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ImplicitMetaPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Rule {
        /// <summary>
        /// Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
        /// </summary>
        [pbr::OriginalName("ANY")] Any = 0,
        /// <summary>
        /// Requires all of the sub-policies be satisfied
        /// </summary>
        [pbr::OriginalName("ALL")] All = 1,
        /// <summary>
        /// Requires a strict majority (greater than half) of the sub-policies be satisfied
        /// </summary>
        [pbr::OriginalName("MAJORITY")] Majority = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
